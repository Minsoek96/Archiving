# TCP(Transmission Control Protocol)

애플리케이션 사이에서 안전하게 데이터를 통신하는 규악이다.
TCP는 호스트 간의 데이터 전송을 관리하고, 신뢰성, 흐름 제어, 오류 검출 및 수정 등의 기능을 제공함으로써 안정적인 데이터 통신을 보장한다.

1. **연결 지향**
   - TCP 데이터를 전송하기 전에 호스트 간에 연결을 설정하는 과정(3-way handShake)
2. **신뢰성**
   - TCP는 데이터의 손실, 중복, 순서 변경을 방지한다. 데이터가 손실되면 TCP는 자동으로 재전송하며, 데이터가 순서대로 도착하는지 확인하고, 도착하지 않는 데이터는 요청하여 재전송 받을 수 있따.
3. **흐름제어**
   - TCP는 수신자의 처리 속도를 고려하여 송신자가 너무 빠르게 데이터를 보내지 않도록 조절한다. 이를 통해 네트워크 과부하를 방지한다.
4. **혼잡제어**
   - TCP는 네트워크가 혼잡해지는 경우 송신 속도를 줄여 네트워크 트래픽을 조절한다.

## 구조

![tcp](/dev/network/tcp.png)

- **Offset (Data Offset)**
  - TCP 헤더의 길이를 나타낸다.
- **Reserved**
  - 현재는 사용되지 않는 예약 필드이다.
- **TCP Flags**
  - TCP 세션의 상태를 나타내는 8개의 플래그로 구성되어 있다. 각각 의 플래그는 특정 상황에서 설정된다.
- **Window**
  - 흐름 제어를 위한 윈도 크기를 나타낸다. 송신 측이 한번에 보낼 수 있는 데이터의 양을 제한한다.
- **checksum**
  - 헤더와 데이터의 무결성을 확인하기 위한 오류 검출 값
- **Urgent Pointer**
  - 긴급 데이터가 포함된 경우, 이 필드는 긴급 데이터가 끝나는 위치를 나타낸다. `URG` 플래그가 설정된 경우에만 유효하다.

### TCP 플래그

1비트 크기의 필드로, 연결 상태나 데이터 전송 상태를 제어하는 데 사용된다. 총 8개의 플래그가 있으며, 하나의 TCP 패킷에서 여러 플래그가 동시에 설정될 수 있다.

#### URG(Urgent Flag) - 긴급 플래그

긴급 데이털르 처리해야 할 때 설정된다. `Urgent Pointer`필드와 연관되며, 이 플래그가 설정되면 긴급 데이터가 있다고 해석되어 수신 측에서 이를 우선 처리하게 된다.

> 긴급 메시지를 보낼 때 사용되며, 일반적인 데이터보다 먼저 처리되어야 한다.

#### ACK(Acknowlegment Flag) - 확인 응답 플래그

수신자가 송신자의 데이터를 잘 받았음을 알리는 응답 플래그이다.
`Acknowledgment Number` 필드가 유효한 경우 설정된다. `3-way handshake`의 두번 째 단계에서 사용된다.

> 데이터를 제대로 수신 했는지 송신 측에 알려준다. TCP통신에서 거의 항상 사용된다.

#### PSH(Push Flag) - 푸시 플래그

송신 측에서 수신 측으로 데이터를 빠르게 전송해야 할 때 사용된다.  
즉시 전송을 요청하는 플래그로, 데이터를 패킷의 버퍼에 저장하지 않고 바로 상위 계층으로 전달하라고 수신 측에 지시한다.

> 대기 시간을 줄이기 위해 사용된다. 예를 들어 실시간 채팅 애플리케이션 데이터를 지연 없이 전달하기 위해 사용된다.

#### RST(Reset Flag) - 리셋 플래그

비정상적인 상황에서 연결을 재설정하거나 강제 종료할 때 사용된다.  
주로 통신 중 에러가 발생했을 때나, 예상치 못한 패킷을 수신했을 때 연결을 강제로 초기화하는 데 사용된다.

> 연결을 복구할 수 없을 때 TCP 세션을 종료하고 다시 연결을 시작한다.

#### Sync(Syncronize Flag) - 동기화 플래그

연결을 설정할 때 초기 순서 번호(SYN)을 동기화하기 위해 사용된다.  
**3-way handshake**의 첫 번째 단계에서 사용된다. 이 플래그는 송신 측에서 수신 측에 연결을 요청할 때 사용된다.

> TCP 연결을 시작할 때 동기화 요청을 보낸다.

#### FIN(Finish Flag) - 종료 플래그

더 이상 보낼 데이터가 없음을 나타내며, 연결을 종료하려고 할 때 사용된다. **4-way handshake**에서 사용되며, 송신 측에서 더 이상 데이터를 전송하지 않겠다고 알린다.

> TCP 세션을 정상적으로 종료할 때 사용된다.

## TCP를 이용한 통신 과정

TCP를 이용한 데이터 통신을 할 때 프로세스와 프로세스를 연결하기 위해 가장 먼저 수행되는 과정

1. 클라이언트가 서버에게 요청 패킷을 보내고
2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보내고
3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다.

위의 3개의 과정을 3way Handshake라고 부른다.

### 연결 수립 과정

![3way](/dev/network/3way1.png)

1. **SYN 패킷 전송**

   - 클라이언트는 서버에게 요청을 담은 SYN(synchronize) 패킷을 보낸다.
   - 초기 시퀀스 번호는 랜덤으로 설정된다.
   - 상태는 **SYN_SENT**로 표기된다.

2. **SYN+ACK 패킷 응답**

   - 서버는 클라이언트의 요청을 수락하고, 자신의 초기 시퀀스 번호 `ISN(S)`와 클라이언트의 시퀀스 번호를 ACK로 응답하는 SYN-ACK(Synchronize-Acknowledge)패킷을 클라이언트에게 전송한다.
   - 이 패킷에는 랜덤한 시퀀스 번호와 ACK = ISN(S) + 1이 포함된다.
   - 서버 상태는 : **LISTENING(초기서버상태)** -> **SYN_RECEIVED**

3. **ACK 패킷 전송**
   - 클라이언트는 서버의 **SYN+ACK** 패킷을 수신한 후, 최종적으로 수락하는 **ACK(Acknowledge)** 패킷을 서버에 전송한다.
   - ACK = ISN(S) + 1이 포함된다.
   - 클라이언트 상태 : **ESTABLISHED**

### TCP를 이용한 데이터 송수신 과정

TCP를 이용한 데이터 통신을 할 때 단순히 TCP 패킷만을 캡슐화해서 통신하는 것이 아닌 페이로드를 포함한 패킷을 주고 받을 때의 일정한 규칙

![data](/dev/network/tcp-data.PNG)
![3waydata](/dev/network/3way3.png)

1. 송신 쪽에서의 SEQ 번호와 ACK 번호

   - 송신자는 데이터 패킷을 보낼 때, 이전 패킷의 SEQ 번호와 ACK 번호를 유지
   - SEQ = N, ACK = M

2. 수신자 쪽에서 SEQ 번호

   - 수신한 ACK 번호를 자신의 SEQ 번호로 설정
   - 즉, 수신자가 받은 ACK 번호가 다음에 수신할 패킷의 SEQ 번호가된다.

3. 수신자 쪽에서의 ACK 번호
   - 수신자는 송신자가 보낸 데이터의 크기를 기준으로 ACK번호를 설정한다.
   - 수신한 SEQ 번호에 데이터의 크기를 더한 값이 ACK 번호가 된다.

#### 연결 종료

TCP에서의 4-way handShake는 연결 종료를 위한 과정으로, 클라이언트와 서버간의 안정적인 연결을 정상적으로 해제하는 데 사용된다.

1. **FIN 패킷 전송 (클라이언트)**

   - 클라이언트가 먼저 연결을 종료하려고 결정하면 FIN패킷을 전송한다.
   - 더 이상 전송할 데이터가 없다는 신호 이다.
   - 클라이언트 상태 : `FIN_WAIT_1` 상태로 전환된다.
   - TCP연결은 `Half-Close` 상태가 된다. 반대쪽에서는 아직 데이터를 보낼 수 있는 상태를 의미 한다.

2. **ACK 패킷 응답 (서버)**

   - 서버는 클라이언트의 FIN 패킷을 수신한 후, 이를 수락하는 ACK`(Acknowledgement) 패킷을 클라이언트에 전송한다.
   - ACK패킷은 클라이언트의 `FIN` 패킷에 대한 확인 응답
   - (ACK)M = (SYN)N + 1로 설정
   - 서버는 `CLOSE_WAIT` 상태 전환
   - 서버로 부터 `ACK` 응답을 받은 클라이언트 `FIN_WAIT_2`의 상태로 전환된다.

> FIN_WAIT_1은 ACK를 기다리는 상태  
 FIN_WAIT_2는 FIN을 기다리는 상태

3. **FIN 패킷 전송 (서버)**

   - 서버는 클라이언트와의 데이터 전송이 완료된 후, 연결 종료를 위해 `FIN`패킷을 클라이언트에 전송한다.
   - 서버는 이 패킷을 보내고 `LAST-ACK` 상태로 전환된다.

4. **ACK 패킷 응답 (클라이언트)**
   - 클라이언트는 서버의 `FIN`패킷을 수신한 후, 이를 수락하는 `ACK`패킷을 서버에 전송한다.
   - 이 `ACK`패킷은 서버의 `FIN`패킷에 대한 확인 응답
   - (ACK)M = (SYN)N + 1로 설정
   - 클라이언트는 `TIME_WAIT` 상태로 전환, 이 상태에서 일정 시간 동안 대기한 후 연결을 종료한다.
   - 서버는 이 `ACK`패킷을 수신하면 `CLOSED` 상태로 전환되어 연결이 완전히 종료된다.
